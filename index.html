<!DOCTYPE html>
<html>

<head>
     <!-- 检查 viewport 设置是否正确 -->
     <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <style>
        /* A simple CSS reset that removes the default margin, padding, and border of all elements */
        * {
            margin: 0;
        }

        /*
          5. Improve media defaults
        */
        img,
        picture,
        video,
        canvas,
        svg {
            display: block;
            max-width: 100%;
        }

        /*
          6. Remove built-in form typography styles
        */
        input,
        button,
        textarea,
        select {
            font: inherit;
        }

        /*
          7. Avoid text overflows
        */
        p,
        h1,
        h2,
        h3,
        h4,
        h5,
        h6 {
            overflow-wrap: break-word;
        }

        /*
          8. Create a root stacking context
        */
        #root,
        #__next {
            isolation: isolate;
        }

        code,
        kbd,
        samp {
            font-family: monospace, monospace;
            /* 1 */
            font-size: 1em;
            /* 2 */
        }

        p {
            font-family: "Trebuchet MS", Verdana, sans-serif;
        }



        @supports (-webkit-touch-callout: none) {
            body {
                -webkit-user-select: none;
                -webkit-tap-highlight-color: transparent;
                /* Disable tap highlight */
            }
        }

        html {
            -webkit-user-select: none;
            /* Disable text selection */
            -webkit-touch-callout: none;
            -webkit-tap-highlight-color: transparent;
            /* Disable tap highlight */
        }

        #cursor {
            position: absolute;
            display: none;
            z-index: 1000;
        }

        .rectangle {
            position: absolute;
            border: 1px solid #0696D7;
            display: none;
        }

        .face{
            position:absolute;
            border: 2px solid #000000;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            background-color: #7e7e7e;    /* 添加填充色，使用与边框相同的颜色*/
            width: 200px;
            height: 200px;
            box-sizing: border-box;
            z-index: 1000;
    /* 或者使用半透明填充色 */
        }

        .snackbar {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgb(255, 255, 255);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
            width: calc(100% - 128px);  /*两边各64px的边距*/
            max-width: 600px;           /* 可选：设置最大宽度*/
            padding: 8px 12px;
            z-index: 2000;
            border-radius: 4px;
            min-height: 40px;
            max-height: 140px;
            display: flex;
            align-items: center;
            font-size: 18px !important;
        }
        .snackbar p {
            margin: 0;
            width: 100%;
            display: -webkit-box;
            -webkit-line-clamp: 2;       /*显示行数*/
            -webkit-box-orient: vertical;
            overflow: hidden;
            text-align: center;
          }

        .snackbar code {
              vertical-align: middle;  /* code 标签垂直对齐*/
          }


        /* CSS */
        #grid-container {
            position: relative;
            height: 100vh;
            width: 100vw;
            overflow: hidden;
            transform-origin: top left;
            z-index: 0;
        }

        .grid-item {
            position: absolute;
            border: 1px solid rgba(203, 203, 203, 0.20);
            box-sizing: border-box;
            transform-origin: top left;
            z-index: 0;
        }

        .grid-item.thick-right {
            border-right-width: 2px;
            z-index: 0;

        }

        .grid-item.thick-bottom {
            border-bottom-width: 2px;
            z-index: 0;
        }

        .middle-vertical {
            border-right-color: green !important;
            z-index: 100;
        }

        .middle-horizontal {
            border-bottom-color: red !important;
            z-index: 100;
        }

        .toolbar {
            position: fixed;
            left: 0;
            bottom: 0;
            width: 100%;
            height: 60px;
            /* Adjust width as needed */
            background-color: #F5F5F5;
            z-index: 1000;
            display: flex;       /* 添加 flex 布局以便于内部元素排列*/
            justify-content: center;  /* 水平居中内部元素*/
            align-items: center;     /* 垂直居中内部元素*/
            gap: 16px;  /* 圆形之间的间距 */
        }

        .toolbar .circle {
            width: 24px;
            height: 24px;
            border: 1px dashed #808080;
            border-radius: 50%;
            box-sizing: border-box;
        }
        
        

       

    </style>
</head>

<body>
    <div class="snackbar">
        <p><code>Doubletap + hold</code> to accesss precise
            cursor.</p>
    </div>
    <div class="toolbar" style="justify-content: flex-start; padding-left: 20px;">
        <div class="circle"></div>
        <div class="circle"></div>
        <div class="circle"></div>
        <div class="circle"></div>
        <div class="circle"></div>
        <div class="circle"></div>
    </div>
    <div class="face">
    </div>
    <svg id="cursor" width="87" height="87" viewBox="0 0 87 87" fill="none" xmlns="http://www.w3.org/2000/svg">
        <line y1="43.5" x2="38" y2="43.5" stroke="black" />
        <line x1="49" y1="43.5" x2="87" y2="43.5" stroke="black" />
        <line x1="43.5" y1="38" x2="43.5" y2="2.18557e-08" stroke="black" />
        <line x1="43.5" y1="87" x2="43.5" y2="49" stroke="black" />
        <rect x="38.5" y="38.5" width="10" height="10" stroke="black" />
    </svg>

    <div id="grid-container"></div>


    <script>
        /*Initialize variables*/
        var cursor = document.getElementById('cursor');
        var rectangle = document.getElementById('rectangle');
        var start = null;
        var secondTap = false;
        var tapCount = 0;
        var tapTimeout = null;
        var snackbar = document.querySelector('.snackbar'); /*Get the snackbar element*/
        /*Initialize a counter for the rectangles*/
        var rectangleCount = 0;
        var rectangle;



        /*Handle touchstart event*/
        document.addEventListener('touchstart', function (e) {
            e.preventDefault();
            clearTimeout(tapTimeout);
            tapCount++;
    

            /*If double tap, display the cursor*/
            if (tapCount === 2) {
                cursor.style.top = (e.touches[0].clientY - 100) + 'px';
                cursor.style.left = (e.touches[0].clientX - 50) + 'px';
                cursor.style.display = 'block';
            }

            if (cursor.style.display === 'block') {
                snackbar.style.display = 'block';
                snackbar.innerHTML = '<p>slide to hover over the face.</p>';
            }

            /*Handle multi-touch scaling*/
            if (e.touches.length > 1) {
                /*Get two touch points*/
                const touch1 = e.touches[0];
                const touch2 = e.touches[1];
                
                /*Calculate the initial distance between the two touch points*/
                const initialDistance = Math.hypot(
                    touch2.clientX - touch1.clientX,
                    touch2.clientY - touch1.clientY
                );

                /*Store the initial state*/
                const face = document.querySelector('.face');
                const grid = document.getElementById('grid-container');
                const initialFaceRect = face.getBoundingClientRect();
                const initialGridRect = grid.getBoundingClientRect();

                /*Listen to touchmove events for scaling*/
                document.addEventListener('touchmove', function handleScale(e) {
                    if (e.touches.length > 1) {
                        const newTouch1 = e.touches[0];
                        const newTouch2 = e.touches[1];
                        
                        /*Calculate the new distance*/
                        const newDistance = Math.hypot(
                            newTouch2.clientX - newTouch1.clientX,
                            newTouch2.clientY - newTouch1.clientY
                        );
                        
                        /*Calculate the scaling ratio*/
                        const scale = newDistance / initialDistance;
                        
                        /*Update the face size*/
                        face.style.width = `${initialFaceRect.width * scale}px`;
                        face.style.height = `${initialFaceRect.height * scale}px`;
                        
                        /*Update the squareSize*/
                        const newSquareSize = squareSize * scale;
                        const gridItems = document.querySelectorAll('.grid-item');
                        gridItems.forEach(item => {
                            item.style.width = `${newSquareSize}px`;
                            item.style.height = `${newSquareSize}px`;
                        });
                    }
                });

                /*Clean up the event listeners*/
                document.addEventListener('touchend', function cleanup() {
                    document.removeEventListener('touchmove', handleScale);
                    document.removeEventListener('touchend', cleanup);
                });
            }

            // If multi-touch, handle rectangle display and position
           /*
            if (e.touches.length > 1) {

                if (start) {
                    if (secondTap) {
                        start = null;
                        secondTap = false;
                    } else {
                        secondTap = true;

                    }
                } else {
                    // Create a new rectangle if one is not currently being created
                    if (!rectangle) {
                        rectangle = document.createElement('div');
                        rectangle.className = 'rectangle'; // Add class
                        rectangle.id = 'rectangle' + (++rectangleCount); // Add unique id
                        rectangle.style.position = 'absolute';
                        document.body.appendChild(rectangle);

                    }

                    start = { x: e.touches[0].clientX, y: e.touches[0].clientY };
                    rectangle.style.left = (start.x - 8) + 'px';
                    rectangle.style.top = (start.y - 58) + 'px';
                    rectangle.style.display = 'block';

                }
            }
            */
        });
        /*Check if the cursor overlaps with the face boundary*/
        function checkCursorOverlap() {
            const face = document.querySelector('.face');
            if (cursor.style.display === 'block' && face) {
                /*Get the cursor center point coordinates*/
                const cursorX = parseInt(cursor.style.left) + 43; /*cursor width的一半*/
                const cursorY = parseInt(cursor.style.top) + 43; /*cursor高度的一半*/
                
                /*Get the face position and size*/
                const faceRect = face.getBoundingClientRect();
                const faceLeft = faceRect.left;
                const faceTop = faceRect.top;
                const faceWidth = faceRect.width;
                const faceHeight = faceRect.height;
                
                /*Check if the cursor overlaps with the face boundary (allow 2px error)*/
                const onLeftEdge = Math.abs(cursorX - faceLeft) <= 2;
                const onRightEdge = Math.abs(cursorX - (faceLeft + faceWidth)) <= 2;
                const onTopEdge = Math.abs(cursorY - faceTop) <= 2;
                const onBottomEdge = Math.abs(cursorY - (faceTop + faceHeight)) <= 2;
                
                /*If the cursor is above the face, change the face color*/
                if (cursorX >= faceLeft && cursorX <= faceLeft + faceWidth &&
                    cursorY >= faceTop && cursorY <= faceTop + faceHeight) {
                    face.style.backgroundColor = '#ababa9'; /*Change to red*/
                } else {
                    face.style.backgroundColor = '#7e7e7e'; /*Restore the original color*/
                }

                /*If the cursor overlaps with any boundary, create a boundary indicator*/
                face.style.borderWidth = '2px';
                face.style.borderStyle = 'solid'; 
                face.style.borderColor = '#000000';

                /*Remove all existing boundary indicators*/
                const oldIndicators = document.querySelectorAll('.edge-indicator');
                oldIndicators.forEach(indicator => indicator.remove());

                if (onLeftEdge) {
                    const leftIndicator = document.createElement('div');
                    leftIndicator.className = 'edge-indicator';
                    leftIndicator.style.position = 'absolute';
                    leftIndicator.style.left = (faceLeft - 2) + 'px';
                    leftIndicator.style.top = (faceTop) + 'px';
                    leftIndicator.style.width = '4px';
                    leftIndicator.style.height = '200px';
                    leftIndicator.style.backgroundColor = '#000000';
                    leftIndicator.style.boxShadow = '0 0 8px #ffffff';
                    leftIndicator.style.zIndex = '1500';
                    document.body.appendChild(leftIndicator);
                }
                if (onRightEdge) {
                    const rightIndicator = document.createElement('div');
                    rightIndicator.className = 'edge-indicator';
                    rightIndicator.style.position = 'absolute';
                    rightIndicator.style.left = (faceLeft + faceWidth - 2) + 'px';
                    rightIndicator.style.top = (faceTop) + 'px';
                    rightIndicator.style.width = '4px';
                    rightIndicator.style.height = '200px';
                    rightIndicator.style.backgroundColor = '#000000';
                    rightIndicator.style.boxShadow = '0 0 8px #ffffff';
                    rightIndicator.style.zIndex = '1500';
                    document.body.appendChild(rightIndicator);
                }
                if (onTopEdge) {
                    const topIndicator = document.createElement('div');
                    topIndicator.className = 'edge-indicator';
                    topIndicator.style.position = 'absolute';
                    topIndicator.style.left = (faceLeft) + 'px';
                    topIndicator.style.top = (faceTop - 2) + 'px';
                    topIndicator.style.width = '200px';
                    topIndicator.style.height = '4px';
                    topIndicator.style.backgroundColor = '#000000';
                    topIndicator.style.boxShadow = '0 0 8px #ffffff';
                    topIndicator.style.zIndex = '1500';
                    document.body.appendChild(topIndicator);
                }
                if (onBottomEdge) {
                    const bottomIndicator = document.createElement('div');
                    bottomIndicator.className = 'edge-indicator';
                    bottomIndicator.style.position = 'absolute';
                    bottomIndicator.style.left = (faceLeft) + 'px';
                    bottomIndicator.style.top = (faceTop + faceHeight - 2) + 'px';
                    bottomIndicator.style.width = '200px';
                    bottomIndicator.style.height = '4px';
                    bottomIndicator.style.backgroundColor = '#000000';
                    bottomIndicator.style.boxShadow = '0 0 8px #ffffff';
                    bottomIndicator.style.zIndex = '1500';
                    document.body.appendChild(bottomIndicator);
                }
            }
        }

        /*Check overlap when cursor moves*/
        setInterval(checkCursorOverlap, 100);





        /*Handle touchmove event*/
        document.addEventListener('touchmove', function (e) {
            e.preventDefault();


            cursor.style.top = (e.touches[0].clientY - 100) + 'px';
            cursor.style.left = (e.touches[0].clientX - 50) + 'px';

            /*If start is defined and not secondTap, adjust rectangle size*/
            if (start && !secondTap) {
                rectangle.style.width = (e.touches[0].clientX - start.x) + 'px';
                rectangle.style.height = (e.touches[0].clientY - start.y) + 'px';
                snackbar.style.display = 'block';
                snackbar.innerHTML = '<p>slide to hover over the face.</p>'; /*Update the snackbar text*/
            }

        });

        /*Handle touchend event*/
        document.addEventListener('touchend', function (e) {
            e.preventDefault();


            /*Handle tap count and snackbar message*/
            if (tapCount < 2) {
                tapTimeout = setTimeout(function () {
                    tapCount = 0;
                }, 300); /*300ms delay to wait for possible second tap*/
            } else if (tapCount === 2) {
                cursor.style.display = 'none';
                tapCount = 0;
            }

            /*Hide cursor if no touch*/
            if (e.touches.length === 0) {
                cursor.style.display = 'none';
                snackbar.style.display = 'none';
                snackbar.style.display = 'block';
                snackbar.innerHTML = '<p><code>Doubletap + hold</code> to accesss precise cursor.</p>';
            }

            /*If secondTap is true, change the border color of the rectangle*/
            if (secondTap) {
                rectangle.style.background = 'rgba(6, 150, 215, 0.2)'; /*Change this to your desired color*/
                rectangle = null; /*Reset rectangle variable*/

                if (!rectangle) {
                    tapCount = 0;
                    start = null;
                    secondTap = false;
                }
            }
        });

        /*Prevent page refresh on drag*/
        window.addEventListener('touchmove', function (e) {
            e.preventDefault();
        }, { passive: false }); /*Use passive: false to make the preventDefault() call effective*/

        /*Handle window load event*/
        window.onload = function () {
            const gridContainer = document.getElementById('grid-container');
            /*Define squareSize as a global variable*/
            window.squareSize = Math.floor(Math.min(window.innerWidth, window.innerHeight) / 20);
            const squaresPerRow = Math.floor(window.innerWidth / squareSize);
            const squaresPerColumn = Math.floor(window.innerHeight / squareSize);

            /*Create grid items*/
            for (let y = 0; y < squaresPerColumn; y++) {
                for (let x = 0; x < squaresPerRow; x++) {
                    const div = document.createElement('div');
                    div.classList.add('grid-item');
                    if ((x + 1) % 5 === 0) div.classList.add('thick-right');
                    if ((y + 1) % 5 === 0) div.classList.add('thick-bottom');
                    if (x === Math.floor(squaresPerRow / 2)) div.classList.add('middle-vertical');
                    if (y === Math.floor(squaresPerColumn / 2)) div.classList.add('middle-horizontal');
                    div.style.width = `${squareSize}px`;
                    div.style.height = `${squareSize}px`;
                    div.style.left = `${x * squareSize}px`;
                    div.style.top = `${y * squareSize}px`;
                    /*Store the original size and position*/
                    div.dataset.originalWidth = squareSize;
                    div.dataset.originalHeight = squareSize;
                    div.dataset.originalLeft = x * squareSize;
                    div.dataset.originalTop = y * squareSize;
                    gridContainer.appendChild(div);
                }
            }

            /*Add touch event handling*/
            let initialDistance = 0;
            let initialScale = 1;
            let currentScale = 1; /*Add tracking of the current scaling ratio*/

            document.addEventListener('touchstart', function(e) {
                if (e.touches.length === 2) {
                    /*Calculate the initial distance between the two touch points*/
                    initialDistance = Math.hypot(
                        e.touches[0].clientX - e.touches[1].clientX,
                        e.touches[0].clientY - e.touches[1].clientY
                    );
                    initialScale = currentScale; /*Use the current scaling value as the initial value*/
                }
            });

            document.addEventListener('touchmove', function(e) {
                if (e.touches.length === 2) {
                    e.preventDefault(); /*Prevent page zoom*/

                    /*Calculate the new distance*/
                    const currentDistance = Math.hypot(
                        e.touches[0].clientX - e.touches[1].clientX,
                        e.touches[0].clientY - e.touches[1].clientY
                    );

                    /*Calculate the scaling ratio*/
                    const scale = (currentDistance / initialDistance) * initialScale;
                    
                    /*Limit the scaling range*/
                    const limitedScale = Math.min(Math.max(scale, 0.5), 2);
                    currentScale = limitedScale; /*Update the current scaling value*/

                    /*Apply scaling to the grid items*/
                    updateGridScale(limitedScale);
                }
            });

            function getCurrentScale() {
                return currentScale; /*Return the current scaling value*/
            }

            function updateGridScale(scale) {
                const gridItems = document.querySelectorAll('.grid-item');
                gridItems.forEach(item => {
                    /*Get the original values*/
                    const originalWidth = parseFloat(item.dataset.originalWidth);
                    const originalHeight = parseFloat(item.dataset.originalHeight);
                    const originalLeft = parseFloat(item.dataset.originalLeft);
                    const originalTop = parseFloat(item.dataset.originalTop);
                    
                    /*Update the size and position, using the original position multiplied by the scaling ratio*/
                    item.style.width = `${originalWidth * scale}px`;
                    item.style.height = `${originalHeight * scale}px`;
                    item.style.left = `${originalLeft * scale}px`;
                    item.style.top = `${originalTop * scale}px`;
                    
                    /*Update the border width*/
                    const baseBorderWidth = scale + 'px';
                    const thickBorderWidth = (2 * scale) + 'px';
                    
                    item.style.borderWidth = baseBorderWidth;
                    
                    if(item.classList.contains('thick-right')) {
                        item.style.borderRightWidth = thickBorderWidth;
                    }
                    if(item.classList.contains('thick-bottom')) {
                        item.style.borderBottomWidth = thickBorderWidth;
                    }
                });
            }
        };
    </script>
</body>

</html>
